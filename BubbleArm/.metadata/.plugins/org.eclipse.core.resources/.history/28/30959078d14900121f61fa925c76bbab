/*
 * FlowRate.c
 *
 *  Created on: Apr 2, 2012
 *      Author: vivid
 */

#include "driver_config.h"

#include "type.h"
#include "timer32.h"
#include "gpio.h"
#include "Flowrate.h"
#include "FreeRTOS.h"
#include "task.h"
#include "UartPacket.h"
#include "main.h"

volatile uint32_t Flowrate[8];
volatile uint32_t count[8];
volatile uint8_t TxBuffer[32];

void prvDataSendTask( void *pvParameters )
{
	uint8_t n;
	portTickType xNextWakeTime;
	pvParameters = pvParameters;

	//Initialize UART
	FlowrateInit();
	PacketInit(115200);
	xNextWakeTime = xTaskGetTickCount();
	for(;;)
	{
		vTaskDelayUntil( &xNextWakeTime, 1000/DATA_SEND_FREQUENCY/portTICK_RATE_MS );
		taskENTER_CRITICAL();
		for (n = 0; n < 8; n++)
		{
			Flowrate[n] = count[n];
			count[n] = 0;
		}
		taskEXIT_CRITICAL();
		for (n = 0; n < 8; n++)
		{
			TxBuffer[(n * 2)] = Flowrate[n];
			TxBuffer[(n * 2 + 1)] = (Flowrate[n] >> 8);
		}
		PacketSend((uint8_t*) TxBuffer, 16);
	}
}

void FlowrateInit()
{
	uint32_t i;

	/* Initialize GPIO (sets up clock) */
	GPIOInit();
	/* Set flow-rate port pins to input */
	GPIOSetDir(FLOWRATE_PORT, FLOWRATE_1_BIT, 0);
	GPIOSetDir(FLOWRATE_PORT, FLOWRATE_2_BIT, 0);
	GPIOSetDir(FLOWRATE_PORT, FLOWRATE_3_BIT, 0);
	GPIOSetDir(FLOWRATE_PORT, FLOWRATE_4_BIT, 0);
	GPIOSetDir(FLOWRATE_PORT, FLOWRATE_5_BIT, 0);
	GPIOSetDir(FLOWRATE_PORT, FLOWRATE_6_BIT, 0);
	GPIOSetDir(FLOWRATE_PORT, FLOWRATE_7_BIT, 0);
	GPIOSetDir(FLOWRATE_PORT, FLOWRATE_8_BIT, 0);

	//enable interrupt on both edge of the flow-rate pins
	GPIOSetInterrupt(FLOWRATE_PORT, FLOWRATE_1_BIT, 0, 1, 0);
	GPIOIntClear(FLOWRATE_PORT, FLOWRATE_1_BIT);
	GPIOIntEnable(FLOWRATE_PORT, FLOWRATE_1_BIT);

	GPIOSetInterrupt(FLOWRATE_PORT, FLOWRATE_2_BIT, 0, 1, 0);
	GPIOIntClear(FLOWRATE_PORT, FLOWRATE_2_BIT);
	GPIOIntEnable(FLOWRATE_PORT, FLOWRATE_2_BIT);

	GPIOSetInterrupt(FLOWRATE_PORT, FLOWRATE_3_BIT, 0, 1, 0);
	GPIOIntClear(FLOWRATE_PORT, FLOWRATE_3_BIT);
	GPIOIntEnable(FLOWRATE_PORT, FLOWRATE_3_BIT);

	GPIOSetInterrupt(FLOWRATE_PORT, FLOWRATE_4_BIT, 0, 1, 0);
	GPIOIntClear(FLOWRATE_PORT, FLOWRATE_4_BIT);
	GPIOIntEnable(FLOWRATE_PORT, FLOWRATE_4_BIT);

	GPIOSetInterrupt(FLOWRATE_PORT, FLOWRATE_5_BIT, 0, 1, 0);
	GPIOIntClear(FLOWRATE_PORT, FLOWRATE_5_BIT);
	GPIOIntEnable(FLOWRATE_PORT, FLOWRATE_5_BIT);

	GPIOSetInterrupt(FLOWRATE_PORT, FLOWRATE_6_BIT, 0, 1, 0);
	GPIOIntClear(FLOWRATE_PORT, FLOWRATE_6_BIT);
	GPIOIntEnable(FLOWRATE_PORT, FLOWRATE_6_BIT);

	GPIOSetInterrupt(FLOWRATE_PORT, FLOWRATE_7_BIT, 0, 1, 0);
	GPIOIntClear(FLOWRATE_PORT, FLOWRATE_7_BIT);
	GPIOIntEnable(FLOWRATE_PORT, FLOWRATE_7_BIT);

	GPIOSetInterrupt(FLOWRATE_PORT, FLOWRATE_8_BIT, 0, 1, 0);
	GPIOIntClear(FLOWRATE_PORT, FLOWRATE_8_BIT);
	GPIOIntEnable(FLOWRATE_PORT, FLOWRATE_8_BIT);

	for (i = 0; i < 8; i++)
	{
		Flowrate[i] = 0;
		count[i] = 0;
	}

	//enable interrupt for timer and pins
	NVIC_EnableIRQ(EINT2_IRQn);

	//setup timer
	LPC_SYSCON->SYSAHBCLKCTRL |= (1<<9);
	LPC_TMR32B0 ->TCR = 0x01;
	LPC_TMR32B1 ->TCR = 0x02;
	LPC_TMR32B1 ->MCR = 0x03;
	LPC_TMR32B1 ->MR0 = SystemCoreClock/10 - 1;
	LPC_TMR32B1 ->TCR = 0x01
}

void PIOINT2_IRQHandler(void)
{
	uint32_t regVal;

	regVal = LPC_GPIO2->MIS;
	LPC_GPIO2->IC = regVal;

	if (regVal & (0x1 << FLOWRATE_1_BIT))
		count[0]++;
	if (regVal & (0x1 << FLOWRATE_2_BIT))
		count[1]++;
	if (regVal & (0x1 << FLOWRATE_3_BIT))
		count[2]++;
	if (regVal & (0x1 << FLOWRATE_4_BIT))
		count[3]++;
	if (regVal & (0x1 << FLOWRATE_5_BIT))
		count[4]++;
	if (regVal & (0x1 << FLOWRATE_6_BIT))
		count[5]++;
	if (regVal & (0x1 << FLOWRATE_7_BIT))
		count[6]++;
	if (regVal & (0x1 << FLOWRATE_8_BIT))
		count[7]++;

	return;
}
